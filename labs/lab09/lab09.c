#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "pico/stdlib.h"
#include <string.h>
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "hardware/adc.h"
#include "lab09.pio.h"

void main_asm();

#define IS_RGBW true        // Will use RGBW format
#define NUM_PIXELS 1        // There is 1 lab09 device in the chain
#define lab09_PIN 28       // The GPIO pin that the lab09 connected to

/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 * 
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb) {
    pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}


/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 * 
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) {
    return  ((uint32_t) (r) << 8)  |
            ((uint32_t) (g) << 16) |
            (uint32_t) (b);
}
/**
 * @brief Function to intialize ADC
 * 
 * @param int input representing the the ADC channel to be selected
 */

void adc_initialization (uint input) {
    adc_init();                             // Initialise the ADC
    adc_set_temp_sensor_enabled(true);      // Enable the temperature sensor
    adc_select_input(input);
}
/**
 * @brief Function to get the readings of ADC
 * 
 * @return uint16_t result 
 */

uint16_t read_Temperature () {
    uint16_t result = adc_read();
    return result;
}
/**
 * @brief converts the raw adc reading into celsius/floating point temp reading and prints the result
 * 
 * @param  uint16_t raw represents the raw reading to be converted
 */

void adc_To_Float(uint16_t raw){
     const float conversion_factor = 3.3f / (1<<12);
     float result = raw * conversion_factor;
     float temp = 27 - (result -0.706)/0.001721;
     printf("The raw reading is : %d\n", raw);
     printf("And its converted temperature reading is: %f C\n", temp);
      if(temp < 10){
        put_pixel(urgb_u32(0x00, 0x1F, 0x00));
    }
    else if(temp >25){
        put_pixel(urgb_u32(0x1F, 0x00, 0x00));
    }
    else{
        put_pixel(urgb_u32(0x00, 0x00, 0x1F));
    }
}

/**
 * @brief LAB #09 - TEMPLATE
 *        Main entry point for the code - calls the main assembly
 *        function where the body of the code is implemented.
 * 
 * @return int      Returns exit-status zero on completion.
 */
int main() {

     stdio_init_all();
     PIO pio = pio0;
     uint offset = pio_add_program(pio, &lab09_program);
     lab09_program_init(pio, 0, offset, lab09_PIN, 800000, IS_RGBW);
     main_asm();

    // Returning zero indicates everything went okay.
    return 0;
}
